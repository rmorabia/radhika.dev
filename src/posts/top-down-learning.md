---
title: "The Top-Down Learning Cycle"
date: "2019-10-16"
---

## Highest-Level Exposure

Twitter, Newsletters, and especially, work & conversations with practitioners. Get mentors to help with this.

Keep a running list of things to learn.

## High-Level Practical

aka How to Do the Technology at Hand.

You should be learning this through some sort of quick form, probably video-oriented. I use Udemy and Egghead.

If no video is available, read through the docs.

**Practice:** Build a very stupid app in Glitch or Repl.it. Just another todo list, just another Game of Life, whatever.

Do this however long you need to to feel comfortable with the core ideas & syntax.

## Mid-Level Software Engineering

aka Theory for Practitioners.

I think the best thing to do here is read. Not the docs, unless the docs have less practical things.

Books, whitepapers, maybe watch some talks, maybe read through the source code? It depends on the topic.

You know how to use the technology, now it's time to take a step back & figure out why the creator(s) made it the way they did. **What problem were they solving?**

I'm not sure about how to practice this yet. I think just doing normal study techniques of how you learn higher-order concepts (aka don't do flash cards) are in order here.

## Low-Level Computer Science

Take a course, read a textbook, learn a new lower-level language. Either way, this should be a mix of reading about theory and exposing yourself to exercises in that theory. It won't be practical to the day-to-day of work, but it will definitely have exercises.

Everything goes back to algorithms or compiler theory or language theory. The trick here is to learn it when you already see the usage in your life.

...

Cycle between the three as needed. It's not linear, but you can't skip steps either.

### Example

**Exposure:** I'm using Redux at work.

**Practical:** I learned to use Redux through [Dan's Egghead course](https://egghead.io/courses/getting-started-with-redux) & [Andrew's Udemy course](https://www.udemy.com/course/react-2nd-edition/).

**Software Engineering:** Reading the Flux architecture stuff that Facebook put out, that Redux and Vuex are based on.

**Computer Science:** Learn about functional programming since Redux is based off of FP principles.

Learning about Functional Programming leads me to learn about Haskell, which is exposure, which leads me back into practical knowledge of Haskell, which leads me to...

The cycle goes on.

...

This is a higher-level thinking post I scribbled on a train. It's supposed to complement the [How I Learn](https://radhika.dev/how-i-learn/) post, which focuses mostly on the high-level practical learning.
